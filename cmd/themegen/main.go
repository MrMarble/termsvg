// Theme generator tool for termsvg.
// Reads JSON theme files from themes/ directory and generates Go code.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// ThemeData represents the JSON structure of a theme file.
type ThemeData struct {
	Fg      string `json:"fg"`
	Bg      string `json:"bg"`
	Palette string `json:"palette"`
}

// ThemeInfo holds parsed theme data for code generation.
type ThemeInfo struct {
	Name             string
	VarName          string
	Fg               string
	Bg               string
	PaletteOverrides string
	WindowBg         string
}

// TemplateData holds data for the builtin theme template.
type TemplateData struct {
	GeneratedAt string
	Themes      []ThemeInfo
}

const (
	defaultRGBA      = "{R: 0, G: 0, B: 0, A: 255}"
	defaultRGBAPlain = "R: 0, G: 0, B: 0, A: 255"
)

const builtinTemplate = `// Code generated by themegen. DO NOT EDIT.
// Generated at: {{ .GeneratedAt }}

package theme

import (
	"image/color"

	termcolor "github.com/mrmarble/termsvg/pkg/color"
)

// builtinThemes is a registry of all built-in themes.
var builtinThemes = map[string]Theme{
{{- range .Themes }}
	"{{ .Name }}": {{ .VarName }},
{{- end }}
}

{{ range .Themes }}
// {{ .VarName }} is the "{{ .Name }}" theme.
var {{ .VarName }} = Theme{
	Name:       "{{ .Name }}",
	Foreground: color.RGBA{ {{ .Fg }} },
	Background: color.RGBA{ {{ .Bg }} },
	Palette:    {{ .VarName }}Palette,
	WindowBackground: color.RGBA{ {{ .WindowBg }} },
	WindowButtons: [3]color.RGBA{
		{R: 255, G: 95, B: 86, A: 255},  // Close
		{R: 255, G: 189, B: 46, A: 255}, // Minimize
		{R: 24, G: 193, B: 50, A: 255},  // Maximize
	},
}

// {{ .VarName }}Palette is the color palette for the "{{ .Name }}" theme.
// It extends the standard xterm palette with custom colors for the first 16 ANSI colors.
var {{ .VarName }}Palette = func() termcolor.Palette {
	p := termcolor.Standard()
	{{ .PaletteOverrides }}
	return p
}()
{{ end }}
`

// colorToGo converts a hex color to Go RGBA struct format.
//
//nolint:dupl // colorToGo and hexToRGBA have slightly different return formats
func colorToGo(hex string) string {
	// Remove # prefix
	hex = strings.TrimPrefix(hex, "#")

	// Handle short form (RGB -> RRGGBB)
	if len(hex) == 3 {
		hex = string(hex[0]) + string(hex[0]) +
			string(hex[1]) + string(hex[1]) +
			string(hex[2]) + string(hex[2])
	}

	if len(hex) != 6 {
		return defaultRGBA
	}

	// Parse hex components
	var r, g, b int
	if _, err := fmt.Sscanf(hex[0:2], "%x", &r); err != nil {
		return defaultRGBA
	}
	if _, err := fmt.Sscanf(hex[2:4], "%x", &g); err != nil {
		return defaultRGBA
	}
	if _, err := fmt.Sscanf(hex[4:6], "%x", &b); err != nil {
		return defaultRGBA
	}

	return fmt.Sprintf("{R: %d, G: %d, B: %d, A: 255}", r, g, b)
}

//nolint:funlen // sequential theme generation steps are clearer in one function
func main() {
	// Find themes directory
	themesDir := "themes"
	if _, err := os.Stat(themesDir); os.IsNotExist(err) {
		// Try from pkg/theme directory
		themesDir = "../../themes"
		if _, err := os.Stat(themesDir); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "Error: themes directory not found\n")
			os.Exit(1)
		}
	}

	// Read all theme files
	entries, err := os.ReadDir(themesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading themes directory: %v\n", err)
		os.Exit(1)
	}

	var themes []ThemeInfo
	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".json") {
			continue
		}

		theme, err := parseThemeFile(filepath.Join(themesDir, entry.Name()))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: failed to parse %s: %v\n", entry.Name(), err)
			continue
		}

		themes = append(themes, theme)
	}

	if len(themes) == 0 {
		fmt.Fprintf(os.Stderr, "Error: no valid theme files found\n")
		os.Exit(1)
	}

	// Generate output file
	outputFile := "pkg/theme/builtin.go"
	if _, err := os.Stat("pkg/theme"); os.IsNotExist(err) {
		outputFile = "builtin.go"
	}

	tmpl, err := template.New("builtin").Parse(builtinTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	file, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	data := TemplateData{
		GeneratedAt: time.Now().Format(time.RFC3339),
		Themes:      themes,
	}

	if err := tmpl.Execute(file, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %d themes in %s\n", len(themes), outputFile)
}

func parseThemeFile(path string) (ThemeInfo, error) {
	data, err := os.ReadFile(path) //nolint:gosec // path is validated theme file
	if err != nil {
		return ThemeInfo{}, err
	}

	var themeData ThemeData
	if err := json.Unmarshal(data, &themeData); err != nil {
		return ThemeInfo{}, err
	}

	// Validate palette has 16 colors
	colors := strings.Split(themeData.Palette, ":")
	if len(colors) != 16 {
		return ThemeInfo{}, fmt.Errorf("palette must have 16 colors, got %d", len(colors))
	}

	// Get theme name from filename
	name := strings.TrimSuffix(filepath.Base(path), ".json")

	// Create variable name (camelCase)
	varName := toVarName(name)

	// Parse colors (foreground/background use field format)
	fg := hexToRGBA(themeData.Fg)
	bg := hexToRGBA(themeData.Bg)

	// Build palette overrides (only first 16 colors)
	var paletteOverrides []string
	for i, c := range colors {
		paletteOverrides = append(paletteOverrides, fmt.Sprintf("p[%d] = color.RGBA%s", i, colorToGo(c)))
	}

	// Window background uses the theme's bg property (terminal background)
	windowBg := bg

	return ThemeInfo{
		Name:             name,
		VarName:          varName,
		Fg:               fg,
		Bg:               bg,
		PaletteOverrides: strings.Join(paletteOverrides, "\n\t"),
		WindowBg:         windowBg,
	}, nil
}

func toVarName(name string) string {
	// Convert kebab-case to CamelCase
	parts := strings.Split(name, "-")
	caser := cases.Title(language.English)
	for i, part := range parts {
		parts[i] = caser.String(part)
	}
	return strings.Join(parts, "")
}

//nolint:dupl // hexToRGBA has different return format than colorToGo
func hexToRGBA(hex string) string {
	// Remove # prefix
	hex = strings.TrimPrefix(hex, "#")

	// Handle short form (RGB -> RRGGBB)
	if len(hex) == 3 {
		hex = string(hex[0]) + string(hex[0]) +
			string(hex[1]) + string(hex[1]) +
			string(hex[2]) + string(hex[2])
	}

	if len(hex) != 6 {
		return defaultRGBAPlain
	}

	// Parse hex components
	var r, g, b int
	if _, err := fmt.Sscanf(hex[0:2], "%x", &r); err != nil {
		return defaultRGBAPlain
	}
	if _, err := fmt.Sscanf(hex[2:4], "%x", &g); err != nil {
		return defaultRGBAPlain
	}
	if _, err := fmt.Sscanf(hex[4:6], "%x", &b); err != nil {
		return defaultRGBAPlain
	}

	return fmt.Sprintf("R: %d, G: %d, B: %d, A: 255", r, g, b)
}
